# hibernateStudy
嘿嘿
    2.基本crud
    3.对象标识符
        在session中使用对象标识符（OID）映射对象(Object)和记录主键(ID)的关系。（数据库中同一条记录，则OID相同，对象相同）。
        主键
            分类：代理主键和业务主键
            代理主键：increment、identity、sequence、hilo、native
                1.increment：由hibernate自动以递增的方式生成OID，数据库中主键并没有选择自增选项。
                2.identity：由数据库生产标识符，即数据库表主键会被hibernate控制配置成自增选项。
                3.sequence：由hibernate根据数据库的序列（每条记录有一个序列）来生成标识符。mysql不支持。
                4.hilo：由hibernate根据high/low算法来生成标识符。
                5.native：由hibernate根据数据库对自动生成标识符的支持能力，来选择identify，sequence或者 hilo。Mysql的话，native=identity。
    4.java对象状态
        4种状态
            临时状态（transient）：不处于缓存中，在数据库中没有对应的记录。
            持久化状态（persistent）：处于缓存中，在数据库中有对应的记录。
            游离状态（detached）：不处于缓存中，在数据库中有对应的记录。
            删除状态（removed）：不处于缓存中，计划被删除。
            load/get：从数据库中加载一个持久化对象。
        4种状态相关方法
            save：将一个临时对象持久化成持久化对象。
            get/load：得到一个持久化对象。查询数据库中没有的对象时：get返回一个null，load会抛出一个ObjectNotFoundException 异常。
            saveOrUpdate：把临时对象或者游离对象变成持久化对象。
            delete：将一个持久化对象从数据库中删除。变成删除状态。
            merge：游离对象和load/get得到的对象是同一个对象，需要合并游离对象后，才能更新游离对象。
            session.close：可以把一个持久化对象变为游离对象。
    5.数据类型的映射
        基本数据类型和集合数据类型，集合独立成为一张表。单纯的数据，没有oid和生命周期 ，不带缓存。
        hibernate  - java - 标准sql  
        参考网址：https://www.cnblogs.com/15157737693zsp/articles/10148845.html
        boolean在mysql中貌似存0和1，0是false，1是true
    6.多对一和一对多
        （单向）多对一：模型类中，多端有一端的类属性。比如学生对学校。
         级联操作：是否级联操作另一端。
         inverse：是否交给对方控制维护双方的关系，默认false，自己维护。true，交给对方后自己就不能控制了。
         (单向）一对多：模型类中，一端有多端的集合类属性。比如省对市。
         (双向）一对多和多对一双重配置
         (自身）一对多和多对一：父子文件夹，同一个类，可能是父也可能是子
    7.继承
        1.单表继承映射：整个继承树映射到一张表。整个配置在父配置文件中。
            discriminator标签，用于在表中添加一个字段，区分子类。
            subclass标签，用于指示出该hbm文件所表示类的子类。
            将继承体系中的所有类信息表示在同一张表中后，只要是这个类没有的属性会被自动赋上null。
            缺点：一个继承树映射到一张表的话，数据冗余较多，会有很多空字段，不符合关系数据库的设计模式。
            优点：查询效率高,数据量不是非常大的时候,推荐使用.
        2.多子表+一父表继承映射：一个子类映射到一张表，存储它特有的属性，父类映射到一张表，存储子类公共属性，子类与父类所对应的表用主键一对一关联起来。
            <joined-subclass>标签，用于指示出该hbm文件所表示类的子类。
                需要包含一个key标签，这个标签指定了子类和父类之间是通过哪个字段来关联的。
            note：
                查询的时候，直接查询指定的子类型，不要查询父类，再转成子类。
            缺点：需要维护的表的个数较多.
            优点：数据冗余较少,查询效率比第3种方式稍高。
        3.多独立子表继承映射：一个子类映射到一张独立表，存储它所有的属性，表之间都是独立的，没有关联的。
            2种实现方式：
                1.配置都写在父配置文件中
                    <class>标签中的"abstract"属性如果值为true则，不会生成表结构。如果值为false则会生成一张无用的表，不会插入数据和使用。                    
                        <union-subclass>标签是用于指示出该hbm文件所表示的类的子类
                            name：子类的全限定名称
                            table：子类对应的表的名称
                            extends：子类的父类，可以不设置，默认为该为<class>标签类的子类
                2.配置分别写在子配置文件中
                    这样的话，只能在子配置文件中配置一对多、多对一等关系了。
            缺点：查询效率不高,同一类继承层次中所有实体类都需要使用同一个主键种子，主键不能设置成自增(native),需要指明为assigned,uuid,等.
            优点：数据冗余比较少。         
            比较：没有那个绝对好与不好，只有最合适，我们根据需要选择一个最为恰当的即可。
                查询速度：第1种方案 > 第3种方案 > 第2种方案。
                解耦程度：第2种方案 > 第3种方案 > 第1种方案。
    8.一对一
         1.按照主键映射
            主键共享，主从表，从表的主键来自主表的主键，从表的主键既是主键又是外键
                主表配置
                    <one-to-one name=" " class="从表类" cascade="all"></one-to-one>
                外表配置
                    <id name=" " column=" ">
                    	<generator class="foreign">	//foreign策略：既是主键又是外键	
                    		<param name="property"> </param>
                    	</generator>
                    </id>
                    <one-to-one name=" " class="主表类" constrained="true"></one-to-one>
         2.按照外键值唯一映射
            外键值唯一，主(many)从(one)表，many-to-one，从表的外键值唯一，这样就确保了记录一对一。
                主表配置
                    <many-to-one name=" " class="从表类" column="本类表的外键" cascade="all" unique="true"></many-to-one>
                从表配置
                    <one-to-one name="bus" class="Bus2" property-ref="address"></one-to-one>
                        <!-- 
                            没有外键方，property-ref：默认情况下，把被关联实体主键字段作为关联字段。有了property-ref，就可以
                            通过它指定被关联实体主键以外的字段作为关联字段。
                         -->
    9.多对多
        需要依靠中间表建立主从表的联合主键，中间表有两端表的主键组成。
        1.单向：只在一端配置多对多
        2.双向：两端配置多对多  
    10.检索策略
        如果程序加载一个持久化对象的目的是为访问他的属性，则可以采用立即加载。如果程序加载一个持久化对象的目的仅仅是为了获得他的引用，则可以采用延迟加载。
        lazy：延迟加载关联表
            配置在一的一端
                true（默认值，一端set上配置）：关联类用到的时候再加载关联表的全部数据。
                fasle（一的一端set上配置）：关联类的数据立即加载。  
                extra（增强型延迟加载）：关联类用到的时候再加载用到的关联表的相关数据。很少很少用到。
            配置在多的一端
                proxy（默认值，多的一端many-to-one上配置）：代理延迟检索，先建立对象和记录的映射，不包含数据，当用到的时候从数据查询数据。
                no-proxy：无代理延迟检索，关联对象是null，用到的时候再查。工作中没有用到过。需要编译时字节码增强，需要额外的工具。   
        batch-size：延迟加载关联表外键数目
            配置在一的一端set，默认值1，只在lazy=true有用。 
            一次性查询n个一端的多端（select * from 多端 where 外键 in （几个一端，按照 id顺序） order by 一端主键）
        fetch：加载关联对象的方式
            配置在一的一端：
            select默认：数据量少的时候。lazy有用。
                先查询主体对象，然后再根据关联外键id向每一个关联对象发一个select查询关联的对象，形成n+1次查询。
            join检索：左外连接查询。 数据量多的时候，lazy无用。因为采用的是外连接查询，同时把一端和多端都查询出来了。
                note：
                    hql查询方式，配置文件设置的join方式不起作用，依旧使用select方式。
                    在其所有他查询方式如get、criteria等是有效的。
                主体对象和关联对象用一句外键关联的sql同时查询出来，不会形成多次查询。
            
                           