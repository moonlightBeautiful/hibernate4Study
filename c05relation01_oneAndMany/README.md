# hibernateStudy
多对一和一对多
    简介：
        2张表，使用主外键关系关联起来。
    一和多种类：4种
        单向多对一：可以通过多的一方来获取一的一方。
            比如学生对学校，学生类有学校类属性，学生配置文件中使用many-to-one标签。
        单向一对多，可以通过一的一方来获取多的一方，
            比如省对市，省类有集合市属性，省配置文件中使用集合标签，包含one-to-many标签。
        双向一对多：一的一方和多的一方可相互获取。
            比如公司和员工，公司类有集合员工属性，员工类有公司属性，配置文件中相互配置一对多和多对一。
        自身一对多，自身即是一的一方(父)又是多的一方(子），表中多个字段作来自于表的主键。
            比如节点，节点类有自身节点属性（父）和自身节点集合属性（子），配置文件中相互配置一对多和多对一。
    级联操作cascade：
        是否级联操作关联另一端。默认none，不会级联操作。
        举例子：   
            比如保存学生的时候，是否级联保存学校。
            如果不设置级联保存，直接保存学生（学生设置临时学校对象）,则抛出异常，临时状态的学校是不能直接被级联保存的。
        建议：
            使用级联保存和更新可，不使用级联删除。
        注解：
             @Cascade(value = {CascadeType.SAVE_UPDATE})
    主外键关系维护inverse：
        是否交给对方控制维护双方的主外键关系。默认false，自己维护主外键关系。true，交给对方后自己就不能维护主外键了。
        举例子：
             默认：
                在2个关联表映射的对象中保存了相互之间的关系，持久化后，就会在表中以主外键的关系关联。
             如果在一端设置了inverse=true
                一端对象设置了另一端的关系，在表中不会出现主外键关系。因为主外键维护交给了另一端。
        建议：
            建议在多的一端维护主外键关系，因为多的一端操作比一的一端操作频繁。
        注解：
            @OneToOne，@OneToMany，@ManyToMany上才有mappedBy属性，ManyToOne不存在该属性
            @OneToMany(mappedBy="多端的关联属性名",fetch=FetchType.EAGER)
            mappedBy 对方（多端）来维护主外键关系
            1、FetchType.LAZY：懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载。
            2、FetchType.EAGER：急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载。
    注解
        多端的一端，外键名称：@JoinColumn(name = "paperId")

                           